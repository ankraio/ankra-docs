---
title: February 2026 Release
description: AI Agentic Mode, Log Explorer, Pod Terminal, Alerting with AI Incident Reports, Metrics Revamp, SOPS with ArgoCD, Variables, CLI & API Updates
---

# February 2026 Release: AI Goes Agentic, Full Observability & Secrets at Scale

This release transforms the AI Assistant into a fully autonomous agent with 58 tools, brings alerting with AI-powered incident reports to every Ankra resource, adds real-time log streaming and pod terminal access, redesigns the metrics experience, and delivers end-to-end SOPS encryption integrated with ArgoCD.

## AI Agentic Mode & Tooling

The AI Assistant now operates in full agentic mode - it autonomously reads your cluster state, executes multi-step workflows, and proposes infrastructure changes with a built-in confirmation system.

**58 Tools Across 4 Categories**:

*Kubernetes Read (19 tools)*:
- `get_pods`, `get_pod_logs`, `get_deployments`, `get_services`, `get_events`
- `get_nodes`, `get_configmaps`, `get_secrets`, `get_ingresses`
- `get_statefulsets`, `get_daemonsets`, `get_jobs`, `get_cronjobs`
- `get_pvcs`, `describe_resource`, `list_namespaces`, `get_resource_quotas`
- `get_cluster_status`, `get_addon_status`

*Kubernetes Write (7 tools)*:
- `restart_deployment`, `scale_deployment`, `scale_statefulset`
- `delete_pod`, `delete_resource`, `apply_manifest`, `patch_resource`

*Stack Management (17 tools)*:
- `design_stack`, `list_stacks`, `get_stack_details`, `list_available_charts`
- Draft operations: `get_current_draft`, `add_addon_to_draft`, `remove_addon_from_draft`, `add_manifest_to_draft`, `remove_manifest_from_draft`, `update_addon_config`, `rename_stack_draft`
- Persistence: `save_draft_to_database`, `load_draft_from_database`, `list_saved_drafts`, `load_stack_as_draft`
- Dependencies: `set_addon_dependency`, `remove_addon_dependency`, `show_addon_dependencies`

*Stack & Addon Lifecycle (15 tools)*:
- `apply_stack_changes`, `deploy_stack`, `add_addon_to_stack`, `update_stack_addon`, `delete_stack`
- `uninstall_addon_from_stack`, `disconnect_manifest_from_stack`
- `list_addons`, `get_addon_details`, `get_addon_history`
- `sync_addon`, `rollback_addon`
- `get_secret_config`

**Autonomous Workflows**: The agent chains up to 10 tool calls per response, reading cluster state and taking action without manual intervention. Read operations execute immediately. Write operations generate an action proposal with a Bill of Materials (BOM) showing exactly which addons and manifests will be created, updated, or deleted.

**Confirmation System**: Every write operation requires explicit user confirmation. The BOM includes:
- Addons to create, update, or delete
- Manifests to create, update, or delete
- Deployment dependencies and ordering
- Rate limits: 5 write actions per conversation, 10 per user per hour

**Interactive Questions**: The agent asks structured questions when it needs input, presenting options in an interactive format for quick responses.

**Page-Aware Context**: The AI automatically knows what you're looking at. It builds its system prompt with:
- RAG documentation context (top 5 relevant docs)
- Active cluster context
- Current page context (stack, addon, pod, or resource being viewed)
- Navigation links for quick resource access

**Real-Time Streaming**: Responses stream in real-time via SSE with tool activity indicators showing what the agent is doing. Stack preview cards visualize proposed changes inline.

[Explore AI Assistant →](/essentials/ai-assistant)

## AI Incident Reports & Root Cause Analysis

When an alert triggers, Ankra automatically generates a detailed AI incident report - no manual investigation required. The report includes root cause analysis, recommended actions, and direct links to continue troubleshooting in the AI chat.

**Automated Analysis Pipeline**:
1. Alert triggers and the system collects cluster data (pod status, Kubernetes events, container logs, job results)
2. AI performs deep analysis to identify the root cause, quoting exact errors from logs and events
3. A structured report is generated with severity assessment, affected resources, and actionable recommendations
4. The report is stored and accessible from the Alerts dashboard, cluster overview, and notification channels

**Analysis Report Contents**:
- **Root Cause**: 2-3 sentence diagnosis identifying the exact issue with evidence from logs and events
- **Severity**: Critical, warning, or info classification
- **Affected Resources**: List of impacted pods, deployments, and related resources
- **Recommended Actions**: 3-5 specific, actionable steps to resolve the issue
- **Conversation Starters**: Pre-built questions to continue investigating in the AI chat
- **Structured Insights**: Individual findings with per-insight severity levels
- **Confidence Score**: AI self-assessment of analysis accuracy (0.1-1.0)

**Analysis Phases**: Each report progresses through: Pending → Collecting → Analyzing → Summarizing → Completed, with status visible in the UI.

**Interactive Follow-Up**: Every incident report includes conversation starters. Click any starter to open the AI chat with full incident context loaded. The agentic AI can then:
- Run additional diagnostics using its 58 tools
- Describe affected resources for deeper inspection
- Apply fixes directly (with confirmation)

**Notification Integration**: Incident reports are delivered alongside alert notifications in your configured channels:
- **Slack**: Rich message with root cause, severity, and affected resources
- **Microsoft Teams**: Formatted card with analysis summary
- **PagerDuty**: Incident details with recommended actions
- **Discord**: Embedded message with analysis highlights
- **Opsgenie**: Alert enrichment with AI analysis
- **Generic Webhooks**: Customizable templates with variables (`{{alert_name}}`, `{{severity}}`, `{{resource_name}}`, `{{cluster_name}}`, `{{triggered_at}}`)

Your team gets the root cause analysis right next to the error - no context switching, no war rooms to figure out what happened.

**Proactive Analysis**: Beyond reactive incident reports, the AI continuously monitors cluster health and surfaces insights before they become incidents:
- Dashboard AI Insights widget with recent analyses
- Cluster overview analysis cards
- Proactive notification banners for emerging issues

[Configure Alerts →](/essentials/alerts) | [AI Incidents →](/essentials/ai-incidents)

## Alerting Built Into All Ankra Resources

The alerting system now monitors every resource type in Ankra, not just clusters. Define alert rules against stacks, addons, manifests, and GitHub repositories.

**Resource Types Monitored**:
- Clusters (health, connectivity, resource utilization)
- Stacks (deployment status, reconciliation failures)
- Addons (sync status, version drift, failures)
- Manifests (apply failures, drift detection)
- GitHub Repositories (sync status, connection issues)

**Alert Rules**:
- Define custom conditions based on resource state, health status, and deployment outcomes
- Filter by resource type, namespace, name patterns, or labels
- Combine multiple conditions with AND/OR logic
- Set severity levels (Critical, Warning, Info) for prioritization

**Lifecycle Management**:
- Cooldown periods prevent alert storms during known maintenance
- Auto-resolve when conditions return to healthy
- Acknowledge alerts to indicate awareness without silencing
- Snooze alerts for a defined duration
- Enable/disable rules without deleting configuration

**Multi-Cluster Support**: Apply alert rules across all clusters in your organisation, or target specific clusters by ID.

**Webhook Notifications**: Six built-in integrations plus generic webhook support:
- Slack (incoming webhooks with rich formatting)
- Microsoft Teams (adaptive cards)
- PagerDuty (incident creation and enrichment)
- Discord (embedded messages)
- Opsgenie (alert creation)
- Generic webhooks (customizable HTTP payloads with template variables)

[Configure Alerts →](/essentials/alerts)

## Log Explorer

Stream logs in real-time from any Kubernetes workload with powerful search, filtering, and multi-pod aggregation.

**Multi-Pod Log Aggregation**:
- Stream logs from up to 20 pods simultaneously
- Select specific containers across pods with multi-select
- Logs are merged chronologically with pod and container tags for identification
- Per-pod error handling - one failing stream doesn't break the others

**Search & Filtering**:
- Full-text search with case-insensitive matching
- Regex search toggle with syntax validation
- Auto-detect log levels from log content (Error, Warn, Info, Debug)
- Toggle log level visibility with filter buttons
- Configurable tail lines: 100, 500, 1000, 5000, or all

**Display Customization**:
- Adjustable font size (10-20px)
- Line wrapping toggle
- Timestamp display
- Fullscreen mode for focused debugging
- Dark theme optimized for log reading

**Streaming Controls**:
- Play/pause for high-volume streams
- Auto-scroll with smart detection (pauses when you scroll up)
- Load older logs by scrolling to the top
- Duplicate detection via content hashing
- Auto-reconnect with exponential backoff on connection loss

**Export**:
- Copy logs to clipboard
- Download logs as a file

**Architecture**: Logs stream via SSE from the backend, which communicates with the cluster agent over NATS. The agent executes `kubectl logs` with streaming, sending chunks back in real-time. Keepalive every 15 seconds with 5-minute idle timeout.

[Log Explorer →](/essentials/logs)

## Terminal to Any Pod

Open an interactive terminal directly into any running pod container from the Ankra dashboard. Debug issues, inspect files, run commands - all without leaving the browser.

**Shell Options**: Choose from `/bin/sh`, `/bin/bash`, `/bin/zsh`, or `/bin/ash`. The default is `/bin/sh` for maximum compatibility.

**Container Selection**: Select the target container from a dropdown when pods have multiple containers (sidecars, init containers).

**Full Terminal Experience**:
- Powered by xterm.js with a dark theme
- Auto-resize adapts to your browser window
- Connection status indicator (connected, connecting, disconnected)
- Base64 encoding for safe stdin/stdout transmission
- Ping/pong keepalive every 30 seconds

**Session Management**:
- 30-minute idle timeout with automatic cleanup
- Session authentication via your existing browser session
- Bidirectional relay through WebSocket → NATS → Cluster Agent → Kubernetes Exec API

**Kubernetes Integration**: The terminal connects via the Kubernetes exec WebSocket API using the SPDY protocol (`v4.channel.k8s.io`) with dedicated channels for stdin, stdout, stderr, errors, and terminal resize events.

## Multi-Select Delete for Kubernetes Resources

Bulk select and delete Kubernetes resources with a safe, progress-tracked workflow. Available across 20+ resource types.

**Selection**:
- Checkbox on each row for individual selection
- Header checkbox with indeterminate state for select-all (visible page)
- Selection count displayed in the bulk actions bar
- Selections automatically reset when filters or pagination change

**Confirmation & Execution**:
- Confirmation dialog shows the list of resources to be deleted (up to 10 displayed)
- Sequential deletion with real-time progress tracking (`1/5`, `2/5`, etc.)
- Per-item success/failure reporting with error details for failures
- Auto-close after 2 seconds on full success
- Query cache invalidation ensures the list updates immediately

**Supported Resource Types**:
Pods, Deployments, StatefulSets, DaemonSets, ReplicaSets, Jobs, CronJobs, Services, Ingresses, IngressClasses, ConfigMaps, Secrets, PersistentVolumes, PersistentVolumeClaims, ServiceAccounts, Roles, RoleBindings, ClusterRoles, ClusterRoleBindings, NetworkPolicies, PodDisruptionBudgets, CustomResourceDefinitions, and StorageClasses.

## Stack Cloning

Clone any stack between clusters with automatic conflict resolution, encrypted value handling, and parent relationship preservation.

**Cross-Cluster Cloning**:
- Clone deployed stacks or draft stacks to any cluster you have access to
- Cloned stacks are always created as drafts for review before deploying
- Same-cluster cloning is prevented to avoid confusion

**Smart Conflict Resolution**:
- If the stack name already exists in the target cluster, Ankra automatically appends a suffix (`-copy`, `-2`, `-3`, `-clone`, or a UUID as fallback)
- Manifest and addon names follow the same resolution logic
- Parent relationships are updated when resources are renamed

**Encrypted Value Handling**:
- SOPS-encrypted values are automatically stripped during cloning for security
- Stripped values are replaced with `ENCRYPTED_VALUE_REMOVED`
- Warnings are included in the clone result listing every stripped path
- You must reconfigure encrypted values in the target cluster

**Optional Addon Configuration**: Choose whether to include addon configurations (Helm values) in the clone, or start fresh with defaults.

**Clone Result**: Returns the new draft ID, final stack name, warnings (name changes, encrypted values), and counts of cloned addons and manifests.

**Dashboard**: Clone dialog with source/target cluster visualization, cluster selector with health status indicators, and automatic redirect to the draft editor on success.

**CLI**:
```bash
# Clone a stack to another cluster
ankra cluster stacks clone my-stack --to target-cluster

# Clone with a custom name
ankra cluster stacks clone my-stack --to target-cluster --name my-stack-staging

# Include addon configurations
ankra cluster stacks clone my-stack --to target-cluster --include-config
```

[Clone Stack Guide →](/guides/clone-stack) | [Clone Cluster Guide →](/guides/clone-cluster)

## Metrics Revamp

Redesigned metrics visualization with new chart components, summary cards, and AI-powered insights.

**New Chart Design**:
- **CPU Usage by Node**: Area chart with gradient fills per node, interactive tooltips with formatted core values, and node selector for drill-down
- **Memory Usage by Node**: Area chart showing GiB consumed over time per node
- **Network Traffic**: Receive and transmit rate charts (MiB/s) per node
- **Disk I/O**: Read/write operations per second
- **Pod Restarts**: Bar chart showing restart counts grouped by namespace to quickly identify unstable workloads

**Summary Cards**: At-a-glance resource utilization displayed in compact cards:
- CPU usage (cores used / total)
- Memory usage (GiB used / total)
- Network throughput
- Pod status (running / total)

**Time Controls**: Select from 15-minute, 1-hour, 3-hour, 6-hour, 12-hour, 24-hour, or 7-day ranges. Configurable auto-refresh intervals keep dashboards current.

**Node-Level Drill-Down**: Click any series in the chart legend to isolate and focus on a specific node. Toggle nodes on and off to compare performance.

**AI Insights**:
- Dashboard AI Insights widget surfaces recent AI-powered health assessments
- Cluster overview analysis cards show proactive findings
- AI identifies anomalies and trends across metrics data
- Insights link directly to the AI chat for deeper investigation

[Cluster Metrics →](/essentials/cluster-metrics) | [Prometheus Integration →](/integrations/prometheus)

## SOPS Integration with ArgoCD

End-to-end secret encryption using SOPS with AGE keys, fully integrated with ArgoCD for automatic decryption during GitOps sync. Encrypt sensitive values in your Git repository while keeping everything else readable.

**Selective Encryption**: Encrypt specific YAML keys (database passwords, API tokens, connection strings) rather than entire files. The rest of the manifest or values file remains readable for code review.

**AGE Key Management**:
- Generate AGE key pairs at the organisation level
- Public key (`age1...`) used for encryption, stored in organisation settings
- Private key (`AGE-SECRET-KEY-...`) stored securely in Vault
- One key pair per organisation, usable across all clusters

**ArgoCD Integration**:
- AGE private key automatically deployed as a Kubernetes Secret (`ankra-sops-age-key`) in the ArgoCD namespace
- Helm-secrets plugin (v4.6.2) and SOPS binary (v3.9.4) installed on the ArgoCD repo-server via init container
- Custom Helm wrapper script intercepts Helm commands, detects SOPS-encrypted values files, and decrypts on-the-fly
- Support for the `secrets://` URI scheme in ArgoCD applications

**Decryption Flow**:
1. Developer encrypts sensitive keys and pushes to Git
2. ArgoCD syncs the repository
3. Repo-server processes Helm charts
4. Helm wrapper detects SOPS-encrypted values files
5. SOPS decrypts using the mounted AGE private key
6. Helm renders templates with decrypted values
7. Resources deployed to the cluster with real secrets

**Key Rotation**: Re-encrypt all content with a new key pair when rotating credentials. The old key is replaced across all clusters automatically.

**CLI Commands**:
```bash
# Encrypt a key in a manifest file
ankra cluster encrypt manifest my-secret --key DB_PASSWORD -f cluster.yaml

# Encrypt a key in addon values
ankra cluster encrypt addon --name grafana --key adminPassword -f cluster.yaml

# Decrypt and display a manifest
ankra cluster decrypt manifest my-secret -f cluster.yaml
```

[SOPS Guide →](/essentials/sops)

## Variables: Organisation, Cluster & Stack Levels

Define reusable variables at three levels with automatic precedence resolution. Keep your infrastructure DRY by centralizing common values.

**Three-Tier Hierarchy**:
- **Organisation Variables**: Apply to all clusters in the organisation. Define shared values like domain names, registry URLs, and team contacts.
- **Cluster Variables**: Override organisation values for a specific cluster. Define environment-specific values like replica counts, resource limits, and feature flags.
- **Stack Variables**: Override cluster values for a specific stack. Define stack-specific configuration like application versions and custom settings.

**Precedence**: Stack variables take highest priority, then cluster, then organisation. When the same variable name exists at multiple levels, the most specific value wins.

**Syntax**: Use `${{ ankra.variable_name }}` in Kubernetes manifests and Helm values files. Variables are resolved at deployment time during IaC generation.

```yaml
# Example: Using variables in a manifest
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  domain: ${{ ankra.domain_name }}
  environment: ${{ ankra.environment }}
  replicas: ${{ ankra.replica_count }}
```

**Secret Variables**: Mark any variable as a secret for masked display in the UI. Secret values show as `••••••••` with a reveal toggle. Copy syntax buttons are available for quick insertion.

**Variable Management**:
- Organisation variables managed in Organisation Settings
- Cluster variables managed in Cluster Settings
- Stack variables managed in the Stack Variables tab
- Full CRUD with inline editing, validation (alphanumeric + underscore, must start with letter), and duplicate name prevention

[Variables Guide →](/essentials/variables)

## CLI v0.1.123 & API Updates

Major CLI update with new SOPS encryption commands and a comprehensive REST API surface for programmatic access.

### CLI v0.1.123: SOPS Encryption Commands

**Breaking Change**: The `ankra cluster sops <secret>` command has been removed and replaced with more granular encryption commands.

**Encrypt Manifest**: Encrypt a specific key in a manifest file referenced by the cluster configuration.
```bash
ankra cluster encrypt manifest <manifest_name> --key <key_name> -f <cluster.yaml>
```

**Encrypt Addon**: Encrypt a specific key in an addon's values file.
```bash
ankra cluster encrypt addon --name <addon_name> --key <key_name> -f <cluster.yaml>
```

**Decrypt Manifest**: Decrypt and display the contents of a manifest file.
```bash
ankra cluster decrypt manifest <manifest_name> -f <cluster.yaml>
```

**Features**:
- Add new encrypted keys to files that are already SOPS-encrypted (as long as they were encrypted with your organisation's key)
- Clear error messages if you try to encrypt a file from a different organisation

### CLI v1.0.0 Feature Overview

The Ankra CLI includes 35+ commands for managing your entire infrastructure from the terminal:

- **Authentication**: SSO login with PKCE (`ankra login`)
- **AI Chat**: Interactive troubleshooting, one-shot questions, cluster health analysis (`ankra chat`)
- **Helm Charts**: Browse, search, and inspect chart details (`ankra charts`)
- **Credentials**: Manage cloud provider and Git credentials (`ankra credentials`)
- **Stacks**: Create, delete, rename, and view change history (`ankra cluster stacks`)
- **Cluster Clone**: Clone stacks from existing clusters or remote URLs (`ankra cluster clone`)
- **API Tokens**: Create and manage tokens for programmatic access (`ankra tokens`)
- **Operations**: List and cancel cluster operations (`ankra cluster operations`)
- **Agent**: Check status, manage tokens, and trigger upgrades (`ankra cluster agent`)

### API Updates

The REST API now provides full coverage for all platform features:
- **Alerts API** (`/org/alerts/*`): Alert management, rules, integrations, triggers, and AI analysis endpoints
- **User API**: Bearer token authentication for CLI access covering chat, clusters, credentials, charts, operations, organisations, SOPS, and tokens
- **OpenAPI Specification**: Interactive API documentation available at the API reference

[Ankra CLI →](/integrations/ankra-cli) | [API Reference →](/api-reference/introduction)

---

Questions or feedback? Reach out on [Slack](https://join.slack.com/t/ankra-community/shared_invite/zt-30r96vykz-BGBKQ_W0F_wQdMeklRuVSg).
